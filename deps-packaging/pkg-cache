#!/bin/sh

. `dirname "$0"`/../build-scripts/functions
set -x
set -e

MYNAME=`basename $0`

# Set to anything except "no" if you want to skip remote cache
CACHE_IS_ONLY_LOCAL=${CACHE_IS_ONLY_LOCAL:-no}

# Check for Jenkins node label and use that as index.
# There can be multiple labels, pick the first one.
firstlabel=${NODE_LABELS%% *}
if [ x"$firstlabel" = x ]
then
    echo "Jenkins has not assigned a LABEL to this node," \
         "you are probably building manually;" \
         "disabling remote sftp cache"  1>&2
    firstlabel=NO_LABEL
    CACHE_IS_ONLY_LOCAL=yes
fi

CACHEDIR=$HOME/.cache/buildscripts_cache
# Binary packages are architecture (label) specific so they need a label subdir
PKGS_CACHEDIR=$CACHEDIR/pkgs
# Source tarballs etc are not
FILES_CACHEDIR=$CACHEDIR/files
# Make sure that we don't write directly to CACHEDIR but to the subdirs mentioned above
unset CACHEDIR

mkdir -p $PKGS_CACHEDIR
mkdir -p $FILES_CACHEDIR

exit_usage()
{
    exec >&2
    echo "$MYNAME listpkgfiles  <pkg>-<version>"
    echo "    lists the full local paths to all files of that package found in cache"
    echo "    if necessary it fetches them from the sftp cache first"
    echo "$MYNAME putpkg  <pkg>-<version> <pkgfiles>..."
    # TODO decide to overwrite or not? probably yes...
    echo "    writes all pkgfiles to the local and remote cache; TODO OVERWRITE OR NOT?"
    echo "$MYNAME listfile  <filename>"
    echo "    given a filename without slashes, the output is the local full"
    echo "    pathname after it's fetched from remote, if needed"
    echo "$MYNAME putfile  <filename>"
    echo "    Stores a file locally and remotely"

    exit 2
}

# Remove directory silently, if empty or with bogus, unimportant
# contents (having no files but only subdirs is also considered bogus,
# the subdir could be just the temporary transfer dir from a previous
# transfer).
rmdir_if_bogus()
{
(                                     # subshell to undo sh -x verbosity
    bogus=yes
    for f in "$1"/*
    do
        # if we find a non-empty file, then we are good
        if [ -f "$f" ]  &&  [ ! -s "$f" ]
        then
            bogus=no
            break
        fi
    done

    [ $bogus = yes ]  &&  [ -d "$1" ]  &&  rm -rf "$1"  ||  true
)
}


retval=73                                       # failure by default

cmd=$1
shift

case "$cmd" in
putpkg)
    if [ x"$1" = x ]  ||  [ x"$2" = x ]  ||  echo "$1" | grep_q '[/ ]'
    then
        fatal  "$MYNAME $cmd:  requires one package name as argument with no slashes or spaces, and many file path arguments"
    fi
    pkgname=$1
    shift

    pkg_cache_dir="$PKGS_CACHEDIR/$firstlabel/$pkgname"

    # Remove bogus or empty dirs
    rmdir_if_bogus $pkg_cache_dir

    if [ -d "$pkg_cache_dir" ]
    then
        # TODO DECIDE if it's better to force copying always
        echo "$MYNAME $cmd: Skipping because package already exists in local cache:  $pkg_cache_dir"  1>&2
    else
        mkdir -p $pkg_cache_dir
        cp "$@" $pkg_cache_dir/

        if [ $CACHE_IS_ONLY_LOCAL = no ]
        then
            cache-sftp putdir  $firstlabel/$pkgname  "$@"
        fi
    fi
    ;;
listpkgfiles)
    if [ x"$1" = x ]  ||  [ x"$2" != x ]  ||  echo "$1" | grep_q '[/ ]'
    then
        fatal  "$MYNAME $cmd:  requires exactly one package name as argument with no slashes or spaces"
    fi
    pkgname="$1"
    pkg_cache_dir="$PKGS_CACHEDIR/$firstlabel/$pkgname"

    # Remove bogus or empty dirs
    rmdir_if_bogus $pkg_cache_dir

    if [ ! -d $pkg_cache_dir ] && [ $CACHE_IS_ONLY_LOCAL = no ]
    then
        mkdir -p $pkg_cache_dir
        cd $pkg_cache_dir
        cache-sftp getdir  $firstlabel/$pkgname
        cd -  >/dev/null
    fi

    rmdir_if_bogus $pkg_cache_dir

    [ -d $pkg_cache_dir ]  &&  echo  $pkg_cache_dir/*  ||  true
    ;;
putfile)
    cp  $1  $FILES_CACHEDIR

    if [ $CACHE_IS_ONLY_LOCAL = no ]
    then
        cache-sftp putfile $1
    fi
    ;;
listfile)
    if [ x"$1" = x ]  ||  [ x"$2" != x ]  ||  echo "$1" | grep_q /
    then
        fatal  "$MYNAME $cmd:  requires exactly one file name as argument with no slashes"
    fi
    filename="$1"

    rm_if_empty $FILES_CACHEDIR/$filename

    if [ ! -f $FILES_CACHEDIR/$filename ] && [ $CACHE_IS_ONLY_LOCAL = no ]
    then
        cd $FILES_CACHEDIR/
        cache-sftp getfile "$filename"
        cd -  >/dev/null
    fi

    [ -f $FILES_CACHEDIR/$filename ]  &&  echo $FILES_CACHEDIR/$filename  ||  true
    ;;
esac
