#!/bin/sh

. `dirname "$0"`/../build-scripts/functions

CACHEDIR=$HOME/.cache/cfengine-buildscripts-distfiles

usage()
{
    exec >&2
    echo "Usage: $0 <distfile> <URL> [<URL> ...]"
    echo "  downloads all files specified in distfile using URLs"
    exit 1
}

info()
{
    echo "I: $@" >&2
}

opts()
{
    if [ $# -lt 2 ]
    then
        usage
    fi

    DISTFILE="$1"
    shift
    URLS="$@"
}

# Compare filename $1 to checksum $2. If $2 starts with "content=" then
# checksum is computed based on *content* of each contained file,
# instead of the downloaded file itself. Is needed for generated
# downloads.
checksum()
{
    FILENAME="$1"
    CHECKSUM="$2"

    TAR=`func_which tar gtar`

    case "$CHECKSUM" in
        content=*)
            CHECKSUM="${CHECKSUM#content=}"              # remove prefix

            rm -rf temp  &&  mkdir -p temp  &&  cd temp

            func_decompress "$FILENAME" | $TAR xf - >/dev/null 2>&1
            # Bogus file created by older versions of tar trying to untar newer archives.
            rm -f pax_global_header

            ACTUAL_CHECKSUM=`find . -type f | env LC_ALL=C sort | xargs cat | func_md5`

            cd ..  &&  rm -rf temp
            ;;
        *)
            ACTUAL_CHECKSUM=`func_md5 $FILENAME` ;;
    esac

    test "$CHECKSUM" = "$ACTUAL_CHECKSUM"
}

file_in_cache()
{
    FILENAME="$1"
    CHECKSUM="$2"

    if [ -f "$CACHEDIR/$FILENAME" ]
    then
        if checksum "$CACHEDIR/$FILENAME" "$CHECKSUM"
        then
            return 0
        else
            info "WARNING: Cached file $FILENAME has wrong checksum."
            rm -f "$CACHEDIR/$FILENAME"
            return 1
        fi
    else
        info "File $FILENAME is not in cache"
        return 1
    fi
}

fetch_file()
{
    FILENAME="$1"
    CHECKSUM="$2"

    OUTFILE="$CACHEDIR/$FILENAME"
    WGET=`func_whereis wget`

    mkdir -p "$CACHEDIR"

    for URL in $URLS
    do
        # Not all wget versions support --no-check-certificate, so try both forms.
        # Also, the standard output of this function is parsed, so let's make sure
        # wget outputs on standard error. That's what it normally does anyway, but
        # misparsed arguments is an exception.
        $WGET --no-check-certificate -t5 "$URL$FILENAME" -O "$OUTFILE" 1>&2  ||  true

        # Sometimes wget returns error, but leaves an empty file
        rm_if_empty "$OUTFILE"

        # Some wget (1.9.1 on AIX) return 0 even when they failed! So we
        # must test for file existence for retrying.
        [ -f "$OUTFILE" ]  ||  $WGET -t5 "$URL$FILENAME" -O "$OUTFILE" 1>&2  ||  true
        rm_if_empty "$OUTFILE"

        # Try one last time after converting https to http.
        if [ ! -f "$OUTFILE" ]  &&  var_contains URL "https"
        then
            newurl=`echo $URL | sed s/https/http/`
            $WGET -t5 "$newurl$FILENAME" -O "$OUTFILE" 1>&2  ||  true
            rm_if_empty "$OUTFILE"
        fi

        if [ -f "$OUTFILE" ]
        then
            if checksum "$OUTFILE" "$CHECKSUM"
            then
                return 0                           # SUCCESSFUL DOWNLOAD
            else
                info "WARNING: Downloaded $URL$FILENAME has wrong checksum. Continuing"
                # wget(1) tends to create empty files even if download did not finish
                rm -f "$OUTFILE"
            fi
        fi
    done

    echo 'If you get a message about "Unsupported scheme", simply upload the' 1>&2
    echo "given file to $CACHEDIR yourself." 1>&2
    return 1
}

get_src()
{
    cat "$DISTFILE"  |  while read CHECKSUM FILENAME OPTS
    do
        file_in_cache "$FILENAME" "$CHECKSUM" \
            || fetch_file "$FILENAME" "$CHECKSUM" \
            || fatal "Unable to fetch $FILENAME"
    done

    cat "$DISTFILE"  |  while read CHECKSUM FILENAME OPTS
    do
        echo "$CACHEDIR/$FILENAME" $OPTS
    done
}

opts "$@"
get_src
